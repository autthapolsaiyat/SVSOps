.PHONY: up down ps restart logs tail psql api api-raw probe ready seed out levels layers card clean \
	fix-fifo backup-now backups-list restore-overwrite restore-new \
	restore-last-name restore-show-levels restore-show-layers restore-show-card \
	backup-prune restore-test help \
	phase1-smoke openapi docs ui caddy-validate caddy-reload logs-api logs-proxy logs-db \
	db-backup db-list-backups db-restore seed-admin db-patch db-reconcile \
	normalize-csv import-csv import-xlsx import token token-debug fe-proxy-test \
	print-api print-vars \
	sql db-products-ext db-products-migrate db-products-seed db-func-upsert db-view-products \
	import-stage-create import-stage-load import-stage-upsert products-upsert-one \
	selftest-products

# ===== Base config =====
DBU   := svs
DBN   := svssystem
HOST  ?= localhost
PORT  ?= 8888                         # proxy port (Caddy) สำหรับ UI/docs/openapi
API   ?= http://localhost:8080/api    # base URL ไป backend (ใช้สำหรับ import)
KEEP  ?= 30
DBR   ?= svssystem_restore

# Import params (แก้ตอนรัน)
CSV     ?=
XLSX    ?=
TEAM_ID ?=
OUT     ?= /tmp/products_fixed.csv
PY      ?= python3
USER    ?= sysop
PASS    ?= 1234@local

# ===== lifecycle =====
up:
	@docker compose up -d --build

down:
	@docker compose down

ps:
	@docker compose ps

restart: ## ใช้ S=backend (หรือชื่อ service) เพื่อรีสตาร์ทเฉพาะตัวนั้น
	@docker compose restart $(S)

logs:
	@docker compose logs -f --tail=200

tail:    ## ใช้ S=proxy (หรือชื่อ service) เพื่อดูล็อกเฉพาะตัวนั้น
	@docker compose logs -f --tail=200 $(S)

# ===== DB / API quick ops =====
psql:
	@docker compose exec -it db psql -U $(DBU) -d $(DBN)

api:
	@curl -sfS $(API)/health | $(PY) -m json.tool 2>/dev/null || curl -s $(API)/health || echo "API not reachable"

api-raw:
	@curl -i $(API)/health

probe:
	@curl -s -o /tmp/svs_api_body.txt -w "HTTP %{http_code}\n" $(API)/health; \
	cat /tmp/svs_api_body.txt; echo

ready:
	@bash -lc 'for i in {1..30}; do \
	  if curl -sf $(API)/health >/dev/null; then echo "API OK"; exit 0; \
	  else sleep 1; fi; \
	done; echo "API not ready"; exit 1'

# ===== stock quick demo =====
seed:
	@docker compose exec -T db psql -U $(DBU) -d $(DBN) < scripts/seed.sql

out:
	@docker compose exec -T db psql -U $(DBU) -d $(DBN) < scripts/seed_out.sql

levels:
	@docker compose exec -it db psql -U $(DBU) -d $(DBN) -c "SELECT i.sku, l.on_hand, l.avg_cost FROM stock_levels l JOIN items i USING(item_id);"

layers:
	@docker compose exec -it db psql -U $(DBU) -d $(DBN) -c "SELECT i.sku, w.wh_code, l.qty_in, l.qty_remaining, l.unit_cost FROM stock_layers l JOIN items i USING(item_id) JOIN warehouses w ON w.wh_id=l.wh_id ORDER BY l.created_at;"

card:
	@docker compose exec -it db psql -U $(DBU) -d $(DBN) -c "SELECT m.move_type, i.sku, m.qty, m.unit_cost, m.moved_at FROM stock_moves m JOIN items i USING(item_id) ORDER BY m.moved_at;"

clean:
	@docker compose down -v
	@rm -rf db/backups/*

fix-fifo:
	@docker compose exec -T db psql -U $(DBU) -d $(DBN) < scripts/fifo_fix.sql

# ===== backup / restore =====
backup-now:
	@docker compose exec db sh -lc 'pg_dump -U $$POSTGRES_USER $$POSTGRES_DB | gzip > /backups/$${POSTGRES_DB}_$$(date +%Y%m%d_%H%M%S).sql.gz' && \
	echo "✔ Backup created in db/backups/"

backups-list:
	@ls -lh db/backups/ | tail -n +1

restore-overwrite:
	@docker compose exec db sh -lc '\
	  DB=$(DBR); \
	  LATEST=$$(ls -1t /backups/svssystem_*.sql.gz | head -n1); \
	  echo Using backup: $$LATEST; \
	  psql -U $$POSTGRES_USER -d postgres -v ON_ERROR_STOP=1 -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='\''$$DB'\'';" || true; \
	  dropdb  -U $$POSTGRES_USER "$$DB" || true; \
	  createdb -U $$POSTGRES_USER "$$DB"; \
	  gunzip -c "$$LATEST" | psql -q -X -v ON_ERROR_STOP=1 -U $$POSTGRES_USER -d "$$DB" \
	' && echo "✔ Restored to database: $(DBR) (overwritten)"

restore-new:
	@docker compose exec -e DB_BASE=$(DBR) db sh -lc '\
	  TS=$$(date +%Y%m%d_%H%M%S); \
	  DB_BASE="$${DB_BASE:-svssystem_restore}"; \
	  DB="$${DB_BASE}_$${TS}"; \
	  LATEST=$$(ls -1t /backups/svssystem_*.sql.gz 2>/dev/null | head -n1); \
	  [ -z "$$LATEST" ] && echo "No backups found in /backups" && exit 1; \
	  echo Using backup: $$LATEST; echo "Creating $$DB"; \
	  createdb -U $$POSTGRES_USER "$$DB"; \
	  gunzip -c "$$LATEST" | psql -q -X -v ON_ERROR_STOP=1 -U $$POSTGRES_USER -d "$$DB"; \
	  echo "$$DB" > /tmp/last_restore_name.txt \
	' && echo "✔ Restored to NEW database (see: make restore-last-name)"

restore-last-name:
	@docker compose exec -it db sh -lc 'cat /tmp/last_restore_name.txt 2>/dev/null || echo "(no restore-new yet)"'

restore-show-levels:
	@docker compose exec -it db sh -lc '\
	  DB=$$(cat /tmp/last_restore_name.txt); \
	  psql -U $$POSTGRES_USER -d "$$DB" -c "SELECT i.sku, l.on_hand, l.avg_cost FROM stock_levels l JOIN items i USING(item_id);" \
	'

restore-show-layers:
	@docker compose exec -it db sh -lc '\
	  DB=$$(cat /tmp/last_restore_name.txt); \
	  psql -U $$POSTGRES_USER -d "$$DB" -c "SELECT i.sku, w.wh_code, l.qty_in, l.qty_remaining, l.unit_cost FROM stock_layers l JOIN items i USING(item_id) JOIN warehouses w ON w.wh_id=l.wh_id ORDER BY l.created_at;" \
	'

restore-show-card:
	@docker compose exec -it db sh -lc '\
	  DB=$$(cat /tmp/last_restore_name.txt); \
	  psql -U $$POSTGRES_USER -d "$$DB" -c "SELECT m.move_type, i.sku, m.qty, m.unit_cost, m.moved_at FROM stock_moves m JOIN items i USING(item_id) ORDER BY m.moved_at;" \
	'

backup-prune:
	@docker compose exec db sh -lc '\
	  KEEP=$(KEEP); \
	  files=$$(ls -1t /backups/svssystem_*.sql.gz 2>/dev/null | awk "NR>$$KEEP{print}"); \
	  if [ -z "$$files" ]; then echo "Nothing to prune. Keeping latest $$KEEP files."; else echo "$$files" | xargs rm -f && echo "Pruned. Keeping latest $$KEEP files."; fi \
	'

# compatibility alias
restore-test: restore-overwrite

# ===== Phase1 / Proxy / Admin =====
phase1-smoke:
	./scripts/phase1_smoke.sh

openapi:
	@curl -s http://$(HOST):$(PORT)/api/openapi.json | jq .info.title

docs:
	open http://$(HOST):$(PORT)/api/docs || xdg-open http://$(HOST):$(PORT)/api/docs

ui:
	open http://$(HOST):$(PORT) || xdg-open http://$(HOST):$(PORT)

caddy-validate:
	@docker run --rm -v "$$(pwd)/reverse-proxy/Caddyfile":/tmp/Caddyfile caddy:2.8 \
	  caddy validate --config /tmp/Caddyfile

caddy-reload:
	-@docker compose exec proxy caddy reload --config /etc/caddy/Caddyfile || true
	-@docker compose restart proxy

logs-api:
	@docker compose logs -f backend

logs-proxy:
	@docker compose logs -f proxy

logs-db:
	@docker compose logs -f db

db-backup:
	@docker compose exec -T db sh -lc 'TS=$$(date +%Y%m%d_%H%M%S); \
	  pg_dump -U "$$POSTGRES_USER" -d "$$POSTGRES_DB" | gzip > /backups/svssystem_$${TS}.sql.gz && \
	  ls -lh /backups | tail -n +20'

db-list-backups:
	@docker compose exec -T db sh -lc 'ls -lh /backups'

# ใช้: make db-restore FILE=svssystem_YYYYmmdd_HHMMSS.sql.gz
db-restore:
	@test -n "$(FILE)" || (echo ">>> ใช้แบบ: make db-restore FILE=xxx.sql.gz" && exit 1)
	@docker compose exec -i db sh -lc 'gunzip -c /backups/$(FILE) | psql -U "$$POSTGRES_USER" -d "$$POSTGRES_DB"'

seed-admin:
	@docker compose exec -T db psql -U $(DBU) -d $(DBN) < scripts/seed_admin.sql
	@echo "✅ seeded admin (user=admin, pass=pass)"

db-patch:
	@docker compose exec -T db psql -U $(DBU) -d $(DBN) < db/init/zz_stock_flow_patch.sql

db-reconcile:
	@docker compose exec -T db psql -U $(DBU) -d $(DBN) -c "SELECT recompute_reserved_all();"

# ===== Import helpers =====

# debug ค่า
print-api:
	@echo "API=$(API)"

print-vars:
	@echo "USER=$(USER)"; echo "PASS=$(PASS)"; echo "API=$(API)"

# token (เสถียร: printf | curl)
token:
	@printf '%s' '{"username":"$(USER)","password":"$(PASS)"}' | \
	  curl -sS -X POST "$(API)/auth/login" \
	    -H 'Content-Type: application/json' \
	    --data-binary @- | jq -r '.access_token'

# debug token ถ้าติด
token-debug:
	@echo "API=$(API)"
	@printf '%s\n' '{"username":"$(USER)","password":"$(PASS)"}' | cat -v
	@printf '%s' '{"username":"$(USER)","password":"$(PASS)"}' | \
	  curl -v -sS -X POST "$(API)/auth/login" \
	    -H 'Content-Type: application/json' \
	    --data-binary @- | jq .

normalize-csv: ## ใช้ CSV=<path> TEAM_ID=<uuid> OUT=<path(default:/tmp/products_fixed.csv)>
	@test -n "$(CSV)" || (echo "usage: make normalize-csv CSV=/path/to.csv TEAM_ID=<uuid> [OUT=/tmp/products_fixed.csv]"; exit 1)
	@test -n "$(TEAM_ID)" || (echo "TEAM_ID is required"; exit 1)
	@$(PY) bin/normalize_products_csv.py --in "$(CSV)" --out "$(OUT)" --team-id "$(TEAM_ID)"

import-csv: ## ใช้ CSV=<path> TEAM_ID=<uuid>
	@test -n "$(CSV)" || (echo "usage: make import-csv CSV=/path/to.csv TEAM_ID=<uuid>"; exit 1)
	@test -n "$(TEAM_ID)" || (echo "TEAM_ID is required"; exit 1)
	@$(MAKE) -s normalize-csv CSV="$(CSV)" TEAM_ID="$(TEAM_ID)" OUT="$(OUT)"
	@TOKEN=$$($(MAKE) -s token); \
	curl -sS -L -X PUT "$(API)/products/import-csv?mode=upsert" \
	  -H "Authorization: Bearer $$TOKEN" \
	  -F "file=@$(OUT)" | jq .

import-xlsx: ## ใช้ XLSX=<path> TEAM_ID=<uuid>
	@test -n "$(XLSX)" || (echo "usage: make import-xlsx XLSX=/path/to.xlsx TEAM_ID=<uuid>"; exit 1)
	@test -n "$(TEAM_ID)" || (echo "TEAM_ID is required"; exit 1)
	@TOKEN=$$($(MAKE) -s token); \
	curl -sS -L -X POST "$(API)/products/import?mode=upsert&default_team_id=$(TEAM_ID)" \
	  -H "Authorization: Bearer $$TOKEN" \
	  -F "file=@$(XLSX)" | jq .

# ===== Dev helper =====
fe-proxy-test:
	@curl -i -s http://localhost:5173/api/health | head -n 1

help:
	@echo "Targets:"; \
	echo "  up / down / ps / restart S=svc / logs / tail S=svc"; \
	echo "  ready / api / api-raw / probe / openapi / docs / ui"; \
	echo "  psql / seed / out / levels / layers / card / fix-fifo / clean"; \
	echo "  backup-now / backups-list / backup-prune KEEP=30"; \
	echo "  db-backup / db-list-backups / db-restore FILE=..."; \
	echo "  restore-overwrite DBR=svssystem_restore"; \
	echo "  restore-new DBR=svssystem_restore  (with timestamp)"; \
	echo "  restore-last-name / restore-show-levels / restore-show-layers / restore-show-card"; \
	echo "  phase1-smoke (run full login/receive/logout flow)"; \
	echo "  caddy-validate / caddy-reload"; \
	echo "  seed-admin / db-patch / db-reconcile"; \
	echo "  token / normalize-csv CSV=... TEAM_ID=... [OUT=/tmp/products_fixed.csv]"; \
	echo "  import-csv CSV=... TEAM_ID=... | import-xlsx XLSX=... TEAM_ID=..."

# ====== Products/Teams/Groups (DB) helpers ======
# run inline SQL: make sql Q="SELECT now();"
DC := docker compose
PSQL := $(DC) exec -T db psql -U $(DBU) -d $(DBN) -v "ON_ERROR_STOP=1"

sql:
	@$(PSQL) -c "$(Q)"

db-products-ext: ## เปิด extension ที่จำเป็น
	@$(PSQL) -c "CREATE EXTENSION IF NOT EXISTS pgcrypto;"
	@$(PSQL) -c "CREATE EXTENSION IF NOT EXISTS pg_trgm;"

db-products-migrate: ## ตาราง teams/product_groups/mappings + index (ข้ามถ้ามีอยู่แล้ว)
	@$(PSQL) -c "CREATE TABLE IF NOT EXISTS teams ( \
	  id UUID PRIMARY KEY DEFAULT gen_random_uuid(), \
	  code TEXT NOT NULL UNIQUE, \
	  name_th TEXT NOT NULL, \
	  name_en TEXT, \
	  owner_display TEXT, \
	  status TEXT NOT NULL DEFAULT 'active', \
	  name TEXT NOT NULL \
	);"
	@$(PSQL) -c "CREATE TABLE IF NOT EXISTS product_groups ( \
	  id UUID PRIMARY KEY DEFAULT gen_random_uuid(), \
	  code TEXT NOT NULL UNIQUE, \
	  name TEXT NOT NULL, \
	  is_domestic BOOLEAN NOT NULL DEFAULT FALSE \
	);"
	@$(PSQL) -c "CREATE TABLE IF NOT EXISTS product_group_map ( \
	  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE, \
	  group_id UUID NOT NULL REFERENCES product_groups(id) ON DELETE CASCADE, \
	  tag TEXT, \
	  PRIMARY KEY (product_id, group_id) \
	);"
	@$(PSQL) -c 'DO $$$$BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = ''team_ownership'') THEN CREATE TYPE team_ownership AS ENUM (''primary'',''secondary''); END IF; END$$$$;'
	@$(PSQL) -c "CREATE TABLE IF NOT EXISTS product_team_map ( \
	  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE, \
	  team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE, \
	  ownership team_ownership NOT NULL DEFAULT 'primary', \
	  PRIMARY KEY (product_id, team_id) \
	);"
	@$(PSQL) -c "CREATE INDEX IF NOT EXISTS idx_products_name_trgm ON products USING GIN (name gin_trgm_ops);"
	@$(PSQL) -c "CREATE INDEX IF NOT EXISTS idx_pgm_prod ON product_group_map(product_id);"
	@$(PSQL) -c "CREATE INDEX IF NOT EXISTS idx_pgm_group ON product_group_map(group_id);"
	@$(PSQL) -c "CREATE INDEX IF NOT EXISTS ix_products_sku ON products(sku);"
	@$(PSQL) -c "ALTER TABLE products ADD COLUMN IF NOT EXISTS is_active BOOLEAN NOT NULL DEFAULT TRUE;"
	@$(PSQL) -c "ALTER TABLE products ADD COLUMN IF NOT EXISTS team_id UUID; \
	             ALTER TABLE products ADD CONSTRAINT fk_products_team \
	             FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE SET NULL; \
	             CREATE INDEX IF NOT EXISTS idx_products_team ON products(team_id);"

db-products-seed: ## seed โค้ดทีม/กลุ่มพื้นฐาน
	@$(PSQL) -c "INSERT INTO product_groups(code,name,is_domestic) VALUES \
	  ('ORG-LOCAL','กลุ่มสินค้าในประเทศ',TRUE), \
	  ('LAB-TOOLS','อุปกรณ์แลบ',FALSE) \
	  ON CONFLICT (code) DO UPDATE SET name=EXCLUDED.name, is_domestic=EXCLUDED.is_domestic;"
	@$(PSQL) -c "INSERT INTO teams(code,name_th,name,name_en,owner_display) VALUES \
	  ('STD','Standard Team','Standard Team',NULL,NULL) \
	  ON CONFLICT (code) DO UPDATE SET name_th=EXCLUDED.name_th, name=EXCLUDED.name;"

db-func-upsert: ## default_team_id / get_or_create_team / get_or_create_group / upsert_product_with_codes
	@$(PSQL) -c 'CREATE OR REPLACE FUNCTION get_or_create_team(p_code TEXT, p_name TEXT DEFAULT NULL) RETURNS UUID AS $$$$DECLARE tid UUID; BEGIN SELECT id INTO tid FROM teams WHERE code=p_code; IF tid IS NULL THEN INSERT INTO teams(code,name_th,name,name_en,owner_display) VALUES (p_code, COALESCE(p_name,p_code), COALESCE(p_name,p_code), NULL, NULL) RETURNING id INTO tid; END IF; RETURN tid; END$$$$ LANGUAGE plpgsql;'
	@$(PSQL) -c 'CREATE OR REPLACE FUNCTION get_or_create_group(p_code TEXT,p_name TEXT,p_domestic BOOLEAN DEFAULT FALSE) RETURNS UUID AS $$$$DECLARE gid UUID; BEGIN SELECT id INTO gid FROM product_groups WHERE code=p_code; IF gid IS NULL THEN INSERT INTO product_groups(code,name,is_domestic) VALUES (p_code,p_name,COALESCE(p_domestic,FALSE)) RETURNING id INTO gid; ELSE UPDATE product_groups SET name=p_name, is_domestic=COALESCE(p_domestic,is_domestic) WHERE id=gid; END IF; RETURN gid; END$$$$ LANGUAGE plpgsql;'
	@$(PSQL) -c 'CREATE OR REPLACE FUNCTION default_team_id() RETURNS UUID AS $$$$DECLARE v UUID; BEGIN SELECT id INTO v FROM teams WHERE code=''STD''; IF v IS NULL THEN v := get_or_create_team(''STD'',''Standard Team''); END IF; RETURN v; END$$$$ LANGUAGE plpgsql;'
	@$(PSQL) -c "ALTER TABLE products ALTER COLUMN team_id SET DEFAULT default_team_id(); UPDATE products SET team_id = default_team_id() WHERE team_id IS NULL;"
	@$(PSQL) -c 'CREATE OR REPLACE FUNCTION upsert_product_with_codes(p_sku TEXT,p_name TEXT,p_unit TEXT,p_team_code TEXT,p_group_code TEXT,p_group_name TEXT,p_is_domestic BOOLEAN DEFAULT NULL,p_group_tag TEXT DEFAULT NULL) RETURNS UUID AS $$$$DECLARE v_pid UUID; v_tid UUID; v_gid UUID; BEGIN IF p_team_code IS NOT NULL AND p_team_code<>'''' THEN v_tid := get_or_create_team(p_team_code,p_team_code); ELSE v_tid := default_team_id(); END IF; IF p_group_code IS NOT NULL AND p_group_code<>'''' THEN v_gid := get_or_create_group(p_group_code, COALESCE(p_group_name,p_group_code), p_is_domestic); END IF; SELECT id INTO v_pid FROM products WHERE sku=p_sku; IF v_pid IS NULL THEN INSERT INTO products(sku,name,unit,team_id) VALUES (p_sku,p_name,p_unit,v_tid) RETURNING id INTO v_pid; ELSE UPDATE products SET name=p_name, unit=p_unit, team_id=COALESCE(v_tid,team_id) WHERE id=v_pid; END IF; IF v_gid IS NOT NULL THEN INSERT INTO product_group_map(product_id,group_id,tag) VALUES (v_pid,v_gid,p_group_tag) ON CONFLICT (product_id,group_id) DO UPDATE SET tag=EXCLUDED.tag; END IF; IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name=''product_team_map'') THEN INSERT INTO product_team_map(product_id,team_id,ownership) VALUES (v_pid,v_tid,''primary'') ON CONFLICT (product_id,team_id) DO NOTHING; END IF; RETURN v_pid; END$$$$ LANGUAGE plpgsql;'

db-view-products: ## สร้าง/อัปเดต view รวม
	@$(PSQL) -c "DROP VIEW IF EXISTS v_products_full;"
	@$(PSQL) -c "CREATE VIEW v_products_full AS \
	  SELECT p.id, p.sku, p.name, p.unit, p.is_active, \
	         t.code AS team_code, \
	         g.code AS group_code, g.name AS group_name, g.is_domestic, \
	         pgm.tag AS group_tag \
	  FROM products p \
	  LEFT JOIN teams t ON t.id = p.team_id \
	  LEFT JOIN product_group_map pgm ON pgm.product_id = p.id \
	  LEFT JOIN product_groups g ON g.id = pgm.group_id;"

# ===== Import (staging ใน DB) =====
import-stage-create:
	@$(PSQL) -c "CREATE TABLE IF NOT EXISTS products_import ( \
	  sku TEXT, name TEXT, unit TEXT, team_code TEXT, \
	  group_code TEXT, group_name TEXT, is_domestic BOOLEAN, group_tag TEXT);"

# ใช้: make import-stage-load CSV=products.csv
import-stage-load:
	@CID=$$($(DC) ps -q db); \
	 test -n "$(CSV)" || (echo "usage: make import-stage-load CSV=products.csv" && exit 1); \
	 docker cp "$(CSV)" $$CID:/tmp/products.csv; \
	 $(PSQL) -c "TRUNCATE products_import; COPY products_import FROM '/tmp/products.csv' CSV HEADER; SELECT count(*) AS rows_loaded FROM products_import;"

import-stage-upsert:
	@$(PSQL) -c "SELECT upsert_product_with_codes(sku,name,unit,team_code,group_code,group_name,is_domestic,group_tag) FROM products_import;"

# อัปเดต/ทดสอบแถวเดียวเร็ว ๆ :
# make products-upsert-one SKU=... NAME=... UNIT=... TEAM=... GROUP=... GNAME=... ISDOM=true TAG="'หมวด'"
products-upsert-one:
	@test -n "$(SKU)" || (echo "SKU is required"; exit 1)
	@test -n "$(NAME)" || (echo "NAME is required"; exit 1)
	@test -n "$(UNIT)" || (echo "UNIT is required"; exit 1)
	@$(PSQL) -c "SELECT upsert_product_with_codes('$(SKU)','$(NAME)','$(UNIT)','$(TEAM)','$(GROUP)','$(GNAME)',$(ISDOM),$(TAG));"

# ชุด self-test รันเรียงครบ (ดีบักง่าย)
selftest-products:
	@$(MAKE) -s db-products-ext
	@$(MAKE) -s db-products-migrate
	@$(MAKE) -s db-products-seed
	@$(MAKE) -s db-func-upsert
	@$(MAKE) -s db-view-products
	@$(MAKE) -s products-upsert-one SKU=TEST-STK-SELF NAME="Self Test Item" UNIT=EA TEAM=STD GROUP=ORG-LOCAL GNAME="กลุ่มสินค้าในประเทศ" ISDOM=true TAG="'ชุด-selftest'"
	@$(MAKE) -s sql Q="SELECT sku,name,team_code,group_code,group_tag FROM v_products_full WHERE sku LIKE 'TEST-STK-%' OR sku='TEST-STK-SELF' ORDER BY sku;"

# --- Multi-line SQL helpers ---
.PHONY: sqlf sqlx products-list
# === SVS-OPS HELPERS (CSV & SQL) START ===
.PHONY: sqlf sqlx products-list clean-csv import-stage-load-clean import-stage-validate products-find products-import-file

# รันไฟล์ .sql: make sqlf F=/path/to/file.sql
# รัน SQL หลายบรรทัดจากตัวแปร QX (ปลอดภัย):
# ตัวอย่าง: make sqlx QX=$'SELECT ...\nFROM ...\nWHERE ...;'
# ดูสินค้า 50 รายการบน view
# ล้าง CRLF/BOM + ตัดบรรทัดว่าง (ไม่แปลง encoding)
# ใช้: make clean-csv CSV=data/import/products.csv OUT=/tmp/products.utf8.csv
clean-csv:
	@test -n "$(CSV)" || (echo "usage: make clean-csv CSV=path/to.csv [OUT=/tmp/products.utf8.csv]"; exit 1)
	@OUT=$${OUT:-/tmp/products.utf8.csv}; \
	tr -d '\r' < "$(CSV)" | awk 'NR==1{ sub(/^\xef\xbb\xbf/,""); print; next } NF>0' > "$$OUT"; \
	echo "$$OUT"

# ล้าง + โหลด + upsert ครบชุด:
# ใช้: make import-stage-load-clean CSV=data/import/products.csv
import-stage-load-clean:
	@test -n "$(CSV)" || (echo "usage: make import-stage-load-clean CSV=path/to.csv"; exit 1)
	@CLEAN=$$($(MAKE) -s clean-csv CSV="$(CSV)" OUT="/tmp/products.utf8.csv"); \
	 $(MAKE) -s import-stage-create; \
	 $(MAKE) -s import-stage-load  CSV="$$CLEAN"; \
	 $(MAKE) -s import-stage-upsert

# ตรวจจำนวนคอลัมน์ (ต้อง = 8) และโชว์ header
# ใช้: make import-stage-validate CSV=/tmp/products.utf8.csv

import-stage-validate:
	@test -n "$(CSV)" || (echo "usage: make import-stage-validate CSV=path/to.csv"; exit 1)
	@printf '%s\n' \
"import csv" \
"p = '$(CSV)'" \
"bad = 0" \
"with open(p, newline='', encoding='utf-8') as f:" \
"    r = csv.reader(f); hdr = next(r, [])" \
"    for i,row in enumerate(r, start=2):" \
"        if len(row) != 8:" \
"            bad += 1; print(f\"Line {i}: {len(row)} cols -> {row}\")" \
"print('Header:', hdr); print('Invalid rows:', bad)" | $(PY)
# ค้น SKU/ชื่อ: make products-find S=TEST
products-find:
	@test -n "$(S)" || (echo "usage: make products-find S=query"; exit 1)
	@$(PSQL) -c "SELECT sku,name,team_code,group_code,group_tag FROM v_products_full \
	             WHERE sku ILIKE '%$(S)%' OR name ILIKE '%$(S)%' \
	             ORDER BY sku LIMIT 100;"

# One-liner: clean + import + upsert + สรุปผล
# ใช้: make products-import-file CSV=data/import/products.csv
products-import-file:
	@test -n "$(CSV)" || (echo "usage: make products-import-file CSV=path/to.csv"; exit 1)
	@CLEAN=$$($(MAKE) -s clean-csv CSV="$(CSV)" OUT="/tmp/products.utf8.csv"); \
	 $(MAKE) -s import-stage-create; \
	 $(MAKE) -s import-stage-load  CSV="$$CLEAN"; \
	 $(MAKE) -s import-stage-upsert; \
	 $(PSQL) -c "SELECT sku,name,team_code,group_code,group_tag \
	             FROM v_products_full \
	             WHERE sku IN (SELECT sku FROM products_import) \
	             ORDER BY sku;"
# === SVS-OPS HELPERS END ===

# --- sqlx override (robust multi-line) ---
